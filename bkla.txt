#!/usr/bin/env python3
# encoding: utf-8
import os
import sys
import cv2
import time
import math
import queue
import rclpy
import threading
import numpy as np

from cv_bridge import CvBridge

from rclpy.node import Node
from rclpy.executors import MultiThreadedExecutor
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.parameter import Parameter

from geometry_msgs.msg import Twist, Pose2D
from std_srvs.srv import Trigger

# 自定义 PID 封装
from sdk.pid import PID
# yolo11 发布的图像和目标检测结果
from sensor_msgs.msg import Image

from interfaces.msg import ObjectsInfo  #  YOLO 发布的消息类型

# 导入机械臂控制消息类型
from ros_robot_controller_msgs.msg import ClawArmStates, ClawArmState

import sdk.common as common

from geometry_msgs.msg import PoseStamped

# from nav2_simple_commander.robot_navigator import BasicNavigator, TaskResult


# === 机械臂控制的简单封装函数 === 
def set_claw_arm(arm_pub, positions):
    """
    positions: 列表 [(id1, angle1, speed1), (id2, angle2, speed2), ...]
    """
    msg = ClawArmStates()
    for (idx, ang, spd) in positions:
        s = ClawArmState()
        s.id = idx
        s.angle = ang
        s.speed = spd
        msg.data.append(s)
    arm_pub.publish(msg)


def normalize_angle(angle):
    """
    让角度归一化到 [0, 360) 之间
    """
    angle %= 360
    if angle < 0:
        angle += 360
    return angle
    
def angle_diff(a, b):
    """
    返回 a - b 的角度差，范围在 [-180, 180]。
    """
    d = normalize_angle(a - b)
    if d > 180:
        d -= 360
    return d



class AutomaticPickNode(Node):
    def __init__(self, node_name='automatic_pick'):
        super().__init__(node_name)
        self.get_logger().info("Init AutomaticPickNode...")

        self.bridge = CvBridge()
        self.image_queue = queue.Queue(maxsize=2)

        # --- 一些全局变量 ---
        self.pick = False
        self.place = False
        self.start_pick = False
        self.start_place = False
        self.stop = True
        self.first_pick_done = True  # Yifei: add a flag for first time's preload


        # 用于处理 YOLO 检测的结果
        self.object_center_x = -1
        self.object_center_y = -1
        self.object_angle = 0.0  # 这里 YOLO 不带角度，可自行设置 0
        self.target_class = ''   # 'red_ring' 或 'yellow_base'

        # PID
        self.linear_pid = PID(P=0.003, I=0., D=0.)
        self.angular_pid = PID(P=0.008, I=0., D=0.)
        self.angular_pid2 = PID(P=0.009, I=0., D=0.)

        # 允许的像素误差
        self.d_y = 10
        self.d_x = 10
        # 是否已经停止计数
        self.count_stop = 0
        self.county_misss = 0



        # 根据需求，从参数或配置文件中获取停止坐标
        self.declare_parameter('pick_stop_pixel_coordinate', [410, 294])
        self.declare_parameter('place_stop_pixel_coordinate', [410, 294])
        self.pick_stop_x, self.pick_stop_y = self.get_parameter('pick_stop_pixel_coordinate').value
        self.place_stop_x, self.place_stop_y = self.get_parameter('place_stop_pixel_coordinate').value

        # 增加新的控制标志
        self.start_place_red = False   # 是否开始"GPS导航到 red_base"
        self.place_red = False         # 是否已经到点，准备执行 place 动作

        # 目标点( 0.0, 1.18, az=180)
        self.red_base_target_x = 0.0
        self.red_base_target_y = -1.45
        self.red_base_target_az = 180.0


        # 也可以多加一些PID
        self.gps_pid_angular_rotate = PID(P=0.8, I=0., D=0.1)
        self.gps_pid_angular_rotate2 = PID(P=0.7, I=0., D=0.1)
        self.gps_pid_linear = PID(P=0.1, I=0., D=0)   # 简单设个值
        self.gps_pid_angular = PID(P=0.02, I=0., D=0)

        

        # # 添加导航控制器
        # self.navigator = BasicNavigator()
        # self.navigator.waitUntilNav2Active()
        
        # # 添加导航完成标志
        # self.nav_completed = False

        # # 发布目标点
        # self.goal_pub = self.create_publisher(PoseStamped, '/goal_pose', 10)

        # 增加导航相关参数
        self.nav_goal = None
        self.navigating = False
        self.goal_tolerance = 0.1  # 目标位置容差（米）
        self.orientation_tolerance = 5.0  # 朝向容差（度）

        # 底盘发布器
        self.mecnum_pub = self.create_publisher(Twist, '/controller/cmd_vel', 1)

        # 机械臂发布器
        self.arm_pub = self.create_publisher(ClawArmStates, '/jetson_v5_controller_node/set_clawarm', 1)

        self.create_subscription(Image, '/yolo11/object_image', self.image_callback, 1)


        # 订阅 yolo11 识别结果 (ObjectsInfo)
        self.obj_sub = self.create_subscription(
            ObjectsInfo,
            '/yolo11/object_detect',        
            self.yolo_objects_callback,
            1
        )

        # 服务: start_pick / start_place / cancel
        cb_group = ReentrantCallbackGroup()
        self.pick_srv = self.create_service(
            Trigger,
            '~/pick',
            self.start_pick_callback,
            callback_group=cb_group
        )
        self.place_srv = self.create_service(
            Trigger,
            '~/place',
            self.start_place_callback,
            callback_group=cb_group
        )
        self.place_red_srv = self.create_service(
            Trigger,
            '~/place_red',
            self.start_place_red_callback,
            callback_group=cb_group
        )
        self.cancel_srv = self.create_service(
            Trigger,
            '~/cancel',
            self.cancel_callback,
            callback_group=cb_group
        )


        # 后台线程1: 用于 move 基于 PID
        self.run_thread_ = threading.Thread(target=self.pick_and_place_loop, daemon=True)
        self.run_thread_.start()

        # 后台线程2: 执行动作(夹取/放置)
        self.action_thread_ = threading.Thread(target=self.action_thread_func, daemon=True)
        self.action_thread_.start()

        # 后台线程3: 显示图像 (队列里取出 yolo11 的图像结果)
        self.display_thread_ = threading.Thread(target=self.display_images, daemon=True)
        self.display_thread_.start()


        
        # 初始化机械臂
        self.arm_init_action()
        self.arm_init_action()
        # self.place_ready_action()
        self.mecnum_pub.publish(Twist())
        self.set_parameter_autodeclare('status', 'init_done')
        self.get_logger().info("AutomaticPickNode inited.")  

      
        
    def set_parameter_autodeclare(self, name, value):
        # 让参数动态声明再设置
        try:
            self.declare_parameter(name, value)
        except Exception:
            pass
        self.set_parameter_raw(name, value)

    def set_parameter_raw(self, name, value):
        # 必须是 rclpy.parameter.Parameter 类型
        param = Parameter(
            name=name,
            value=value if isinstance(value, list) or isinstance(value, bool)
                  else str(value)
        )
        self.set_parameters([param])   


    # --------------------- 显示图像线程 ---------------------
    def display_images(self):
        """
        从 self.image_queue 中获取图像并显示。
        """
        while rclpy.ok():
            try:
                bgr_image = self.image_queue.get(timeout=1)
            except queue.Empty:
                continue

            if bgr_image is not None:
                cv2.imshow("YOLO Output", bgr_image)
                key = cv2.waitKey(1) & 0xFF
                # 如果按下 ESC，退出显示循环
                if key == 27:
                    self.get_logger().info("ESC pressed, closing display window.")
                    break
            else:
                time.sleep(0.01)

        cv2.destroyAllWindows()
    

    # --------------------- 订阅图像的回调 => 入队 ---------------------
    def image_callback(self, ros_image):
        cv_image = self.bridge.imgmsg_to_cv2(ros_image, "bgr8")
        bgr_image = np.array(cv_image, dtype=np.uint8)
        if self.image_queue.full():
            # 如果队列已满，丢弃最旧的图像(if the queue is full, discard the oldest image)
            self.image_queue.get()
        # 将图像放入队列(put the image into the queue)
        self.image_queue.put(bgr_image)



    # --------------------- YOLO 回调 ---------------------
    def yolo_objects_callback(self, msg: ObjectsInfo):
        """
        这里从 YOLO 的识别结果中找出需要的物体( pick 时找 'red_ring' ，place 时找 'yellow_base' )
        并记录它的中心坐标，用于后面的 PID。
        """
        if not (self.start_pick or self.start_place or self.start_place_red):
            return  # 如果没在执行 pick/place，就不处理了

        # 确定当前要识别的目标类别
        if self.start_pick:
            self.target_class = 'blue_ring'
        elif self.start_place:
            self.target_class = 'yellow_base'
        elif self.start_place_red:
            self.target_class = 'blue_base'
        else:
            self.target_class = 'blue_ring'

        # 在 YOLO 检测结果中，找到第一个(或最大的置信度)对应的目标
        best_conf = 0.0
        cx, cy = -1, -1
        for obj in msg.objects:
            if obj.class_name == self.target_class:
                if obj.score > best_conf:
                    best_conf = obj.score
                    # bounding box: (x1, y1, x2, y2)
                    x1, y1, x2, y2 = obj.box
                    cx = (x1 + x2) / 2.0
                    cy = (y1 + y2) / 2.0

        if best_conf > 0.0:
            self.object_center_x = cx
            self.object_center_y = cy
            self.object_angle = 0.0  # YOLO 没有角度，这里给个固定值
        else:
            self.object_center_x = -1
            self.object_center_y = -1
            self.object_angle = 0.0





    # --------------------- 后台线程1：pick_and_place_loop 底盘运动逻辑---------------------
    def pick_and_place_loop(self):
        """
        根据 start_pick / start_place 来决定是否进行底盘移动(PID)。
        """
        rate = self.create_rate(30)
        while rclpy.ok():
            if self.start_pick:
                self.pick_handle()
            elif self.start_place:
                self.place_handle()
            elif self.start_place_red:
                self.place_red_base_handle()
            else:
                # 如果既不是 pick 也不是 place，停止底盘
                if not self.stop:
                    self.stop = True
                    self.mecnum_pub.publish(Twist())
            rate.sleep()

    # --------------------- 小工具：原地左转30度 ---------------------
    def spin_left_deg(self, deg=30):
    	speed = 0.75
    	rad_to_spin = math.radians(deg)
    	time_needed = abs(rad_to_spin / speed)

    	twist = Twist()
    	twist.angular.z = speed if deg > 0 else -speed

    	t0 = time.time()
    	while time.time() - t0 < time_needed and rclpy.ok():
        	self.mecnum_pub.publish(twist)
        	time.sleep(0.05)

    # Check if spin took too long
    	if time.time() - t0 > 2.5:  # tune this threshold
        	self.get_logger().warn("Stuck rotating — moving forward to recover.")
        	twist = Twist()
        	twist.linear.x = 0.2
        	self.mecnum_pub.publish(twist)
        	time.sleep(0.5)
        	self.mecnum_pub.publish(Twist())

    	self.mecnum_pub.publish(Twist())
    	self.get_logger().info(f"Spin {deg} deg done.")
        
        

    def pick_handle(self):
        """
        夹取逻辑：根据 self.object_center_x/y，用 PID 调整底盘
        当误差足够小，停止并设置 self.pick=True => 触发机械臂抓取
        """
        twist = Twist()
        # 1) 先判断有没有检测到目标
        if self.object_center_x >= 0 and self.object_center_y >= 0:
            self.county_misss = 0

            self.get_logger().info("PICK] Center: (%.2f, %.2f), Angle: %.2f" % (self.object_center_x, self.object_center_y, self.object_angle))
            # 2) 前后 PID
            error_y = self.object_center_y - self.pick_stop_y  # 例如 self.pick_stop_y=300
            if abs(error_y) < 20:
                error_y = 0
            self.linear_pid.SetPoint = 0
            self.linear_pid.update(error_y)
            tmp_linear = self.linear_pid.output
            # 限幅
            if tmp_linear > 0.3:
                tmp_linear = 0.3
            if tmp_linear < -0.3:
                tmp_linear = -0.3
            if abs(tmp_linear) < 0.003:
                tmp_linear = 0.0

            # 2) 转向 PID
            error_x = self.object_center_x - self.pick_stop_x  # 例如 self.pick_stop_x=450
            self.angular_pid.SetPoint = 0
            self.angular_pid.update(error_x)
            tmp_angular = self.angular_pid.output
            # 限幅
            if tmp_angular > 0.36:
                tmp_angular = 0.36
            if tmp_angular < -0.36:
                tmp_angular = -0.36
            if abs(tmp_angular) < 0.09:
                tmp_angular = 0.0

            twist.linear.x = tmp_linear
            twist.angular.z = tmp_angular

            self.get_logger().info(
                f"[final_adjust] error_x={error_x:.1f}, error_y={error_y:.1f},"
                f"twist.linear.x={twist.linear.x:.3f}, twist.angular.z={twist.angular.z:.3f}"
            )

            # 判断是否到达误差范围(如果线速度和角速度都为0，则计数+1)
            if abs(tmp_linear) == 0 and abs(tmp_angular) == 0:
                self.count_stop += 1
            else:
                self.count_stop = 0
            if self.count_stop > 10:
                self.pick = True
                self.start_pick = False
                self.count_stop = 0

            self.mecnum_pub.publish(twist)
            self.stop = False

        else:
            self.county_misss += 1
            if self.county_misss > 10:
                self.county_misss = 0
                # 没发现目标，底盘先别动(或可原地旋转找目标)
                self.get_logger().warn("[PICK] Target not found => spin left 45 deg")
                self.spin_left_deg(30)

    def place_handle(self):
        """
        放置逻辑：与 pick 类似，只是换了 target = 'yellow_base'，以及对应的 stop 坐标
        """
        twist = Twist()
        self.get_logger().info(f'{self.object_center_x} {self.object_center_y}')
        if self.object_center_x >= 0 and self.object_center_y >= 0:
            # self.get_logger().info("PLACE] Center: (%.2f, %.2f), Angle: %.2f" % (self.object_center_x, self.object_center_y, self.object_angle))
            # 1) 前后 PID
            self.county_misss = 0
            error_y = self.object_center_y - self.place_stop_y  # 例如 280
            if abs(error_y) < 10:
                error_y = 0
            self.linear_pid.SetPoint = 0
            self.linear_pid.update(error_y)
            tmp_linear = self.linear_pid.output
            # 限幅
            if tmp_linear > 0.3:
                tmp_linear = 0.3
            if tmp_linear < -0.3:
                tmp_linear = -0.3
            if abs(tmp_linear) < 0.003:
                tmp_linear = 0.0

            # 2) 转向 PID
            error_x = self.object_center_x - self.place_stop_x  # 例如 430
            self.angular_pid.SetPoint = 0
            self.angular_pid.update(error_x)
            tmp_angular = self.angular_pid.output
            if tmp_angular > 0.36:
                tmp_angular = 0.36
            if tmp_angular < -0.36:
                tmp_angular = -0.36
            if abs(tmp_angular) < 0.13:
                tmp_angular = 0.0
                # if error_x > 0:
                #     tmp_angular = 0.15
                # else:
                #     tmp_angular = -0.15

            twist.linear.x = tmp_linear
            twist.angular.z = tmp_angular

            self.get_logger().info(
                f"[final_adjust] error_x={error_x:.1f}, error_y={error_y:.1f},"
                f"twist.linear.x={twist.linear.x:.3f}, twist.angular.z={twist.angular.z:.3f}"
            )

            # 判断停止
            if abs(tmp_linear) == 0 and abs(tmp_angular) == 0:
                self.count_stop += 1
            else:
                self.count_stop = 0
            if self.count_stop > 10:
                self.place = True
                self.start_place = False
                self.count_stop = 0

            self.mecnum_pub.publish(twist)
            self.stop = False
        else:
            self.county_misss += 1
            if self.county_misss > 10:
                self.county_misss = 0
                # self.start_place = False
                # self.start_pick = False
                # 没发现目标，底盘先别动(或可原地旋转找目标)
                self.get_logger().warn("[PLACE] Target not found => spin left 30 deg")
                self.spin_left_deg(20)


    def place_red_base_handle(self):
        """
        使用 sdk.pid.PID 的方式分两阶段控制：
        阶段1：原地旋转对准 (x1,y1) 方向
        阶段2：前进靠近目标点，并最终对准 red_base_target_az
        """

        # 3) 准备阶段：清一下 PID 避免积分残留（可选）
        self.gps_pid_linear.clear()
        self.gps_pid_angular.clear()
        self.gps_pid_angular_rotate.clear()


        # ==============================
        # 阶段4：视觉对齐 (参考第二个程序 pick_handle)
        # ==============================
        self.get_logger().info("--- 阶段4：视觉对齐 (基于图像PID) ---")
        
        # 可以设置一个循环次数上限，防止卡死
        max_loops = 100
        loops = 0
        while rclpy.ok() and loops < max_loops:
            # 如果没检测到物体，或者视觉目标不在范围内，就打个日志或让它稍微旋转找目标
            if self.object_center_x < 0 or self.object_center_y < 0:
                self.get_logger().warn("[final_adjust] red_base not found => spin a bit")
                twist = Twist()
                # twist.angular.z = 0.1  # 原地转一下？
                self.mecnum_pub.publish(twist)
                time.sleep(0.2)
                loops += 1
                continue


            self.get_logger().info(
            f"[final_adjust] Detected red_base => center=({self.object_center_x:.1f}, {self.object_center_y:.1f})"
            )
            
            # 下面参考了第二个程序 pick_handle 中做法
            # 1) 计算误差
            error_x = (self.object_center_x - 482)  # 这里数字可根据实际调
            error_y = (self.object_center_y - 100)
            
            # 2) 用 PID
            #    线速度 => 根据 error_y
            self.linear_pid.SetPoint = 0.0
            self.linear_pid.update(error_y)
            tmp_linear = self.linear_pid.output
            # 限幅
            if tmp_linear > 0.3:
                tmp_linear = 0.3
            elif tmp_linear < -0.3:
                tmp_linear = -0.3
            if abs(tmp_linear) < 0.009:
                tmp_linear = 0.0
            
            #    角速度 => 根据 error_x
            self.angular_pid2.SetPoint = 0.0
            self.angular_pid2.update(error_x)
            tmp_angular = self.angular_pid2.output
            if tmp_angular > 0.36:
                tmp_angular = 0.36
            elif tmp_angular < -0.36:
                tmp_angular = -0.36
            if abs(tmp_angular) < 0.003:
                tmp_angular = 0.0
            
            # 发布
            twist = Twist()
            twist.linear.x = float(tmp_linear)
            twist.angular.z = float(tmp_angular)
            self.mecnum_pub.publish(twist)
            
            self.get_logger().info(
                f"[final_adjust] error_x={error_x:.1f}, error_y={error_y:.1f}, "
                f"twist.linear.x={twist.linear.x:.3f}, twist.angular.z={twist.angular.z:.3f}"
            )
            
            # 判断是否到达阈值
            # if 
            if abs(error_x) < 5 and tmp_linear == 0.0 and abs(tmp_angular) < 0.019:

                self.count_stop += 1
            else:
                self.count_stop = 0
            
            if self.count_stop > 10:
                self.place_red = True
                self.start_place_red = False
                self.count_stop = 0
                self.get_logger().info("已完成视觉对齐。")
                break
            
            loops += 1
            time.sleep(0.1)

        if self.place_red == False:
            self.place_red = True
        if self.start_place_red == True:
            self.start_place_red = False
        
        # 停止到底盘
        self.mecnum_pub.publish(Twist())
        time.sleep(0.3)

        # === 重要：重置控制标志，防止重新进入阶段1 ===
        self.start_place_red = False
        self.place_red = False
        self.get_logger().info("整体 place_red_base_handle 结束")



    # --------------------- 后台线程2：action_thread_func(抓取/放置机械臂动作) ---------------------
    def action_thread_func(self):
        """
        pick/place = True 时，触发机械臂动作
        """
        rate = self.create_rate(20)
        while rclpy.ok():
            if self.pick:

                self.get_logger().info("[action_thread] => do arm_pick_action()")
                # 先停止底盘
                self.mecnum_pub.publish(Twist())
                time.sleep(0.3)
                self.arm_init_action()
                # 再往前开一点
                twist = Twist()
                twist.linear.x = float(0.36)  # 0.05m/s
                self.mecnum_pub.publish(twist)
                time.sleep(1.8)
                self.mecnum_pub.publish(Twist())
                time.sleep(0.3)

                # 执行机械臂夹取
                self.arm_pick_action()
                # 收回机械臂
                self.place_ready_action()

                self.pick = False
                self.get_logger().info("[action_thread] pick action done")

                self.start_place = True
                self.stop = False  # 允许继续移动


            if self.place:
                self.get_logger().info("[action_thread] => do arm_place_action()")
                # 先停止底盘
                self.mecnum_pub.publish(Twist())
                time.sleep(0.3)
                self.place_init_action()
                # (可选)再往前开一点
                twist = Twist()
                twist.linear.x = 0.36
                self.mecnum_pub.publish(twist)
                time.sleep(2.0)
                self.mecnum_pub.publish(Twist())
                time.sleep(0.3)

                # 执行放置
                self.arm_place_action()
                # 收回机械臂
                self.place_init_action()

                self.place = False
                self.get_logger().info("[action_thread] place action done")
                self.spin_left_deg(45)
                
                
                self.place = False 
                self.start_pick = True
                self.stop = False


            if self.place_red:
                # 1) 停止底盘
                self.mecnum_pub.publish(Twist())
                time.sleep(0.5)
                self.place_base_init_action()
                # 2) (可选) 再往前走一点
                twist = Twist()
                twist.linear.x = 0.2
                self.mecnum_pub.publish(twist)
                time.sleep(1.8)
                self.mecnum_pub.publish(Twist())

                # 3) 放置
                self.place_base_action()
                self.place_base_action()
                # 收回机械臂
                self.place_base_init_action()

                self.place_red = False
                self.get_logger().info("[action_thread] place_red action done")            

            rate.sleep()


    # --------------------- 机械臂动作示例 ---------------------
    def arm_init_action(self):
        # 初始化机械臂 (示例)
        set_claw_arm(self.arm_pub, [
            (1, 270.0, 50.0),
            (2,   0.0, 50.0)
        ])
        self.get_logger().info("Arm init action done.")
        time.sleep(1.5)

    def arm_pick_action(self):
        # 执行夹取 (示例)
        set_claw_arm(self.arm_pub, [
            (1,  -30.0, 50.0),
            (2,   0.0, 50.0)
        ])
        time.sleep(1.5)
        twist = Twist()
        twist.linear.x = -0.2
        self.mecnum_pub.publish(twist)
        time.sleep(.5)
        self.mecnum_pub.publish(Twist())
        
        
        self.get_logger().info("Arm pick action done.")
        
        time.sleep(1.5)

    def place_init_action(self):
        set_claw_arm(self.arm_pub, [
            (1, 420.0, 50.0),
            (2,   0.0, 0.0)
        ])
        self.get_logger().info("place init action done.")
        time.sleep(1.5)

    def place_base_init_action(self):
        set_claw_arm(self.arm_pub, [
            (1, 480.0, 50.0),
            (2, 0.0, 50.0)
        ])
        self.get_logger().info("place base init action done.")
        time.sleep(1.5)

    def place_ready_action(self):
        set_claw_arm(self.arm_pub, [
            (1, 130.0, 50.0),
            (2,   0.0, 50.0)
        ])
        self.get_logger().info("place ready action done.")
        time.sleep(1.5)

    def arm_place_action(self):
        set_claw_arm(self.arm_pub, [
            (1, 420.0, 50.0),
            (2, 1050.0, 100.0)
        ])
        time.sleep(3)
        
        
        
        
        set_claw_arm(self.arm_pub, [
            (1, 350.0, 50.0),
            (2, -20.0, 100.0)
        ])
        
       
        
        self.get_logger().info("Arm place action done.")
        time.sleep(1.5)
        
        
        
        
    def place_base_action(self):
        set_claw_arm(self.arm_pub, [
            (1, 480.0, 50.0),
            (2, 100.0, 50.0)
        ])
        self.get_logger().info("Arm place base done.")
        time.sleep(1.5)
        


    # --------------------- 服务回调 ---------------------
    def cancel_callback(self, request, response):
        self.start_pick = False
        self.start_place = False
        self.get_logger().info("cancel pick & place")
        response.success = True
        return response

    def start_pick_callback(self, request, response):
        self.get_logger().info("start pick")
        self.set_parameter_autodeclare('status', 'start_pick')
        self.place_ready_action()

        self.start_pick = True
        self.start_place = False
        self.pick = False
        self.place = False

        # 清 PID
        self.linear_pid.clear()
        self.angular_pid.clear()

        # 如果需要从参数 Server 更新 pick_stop_x / pick_stop_y
        self.pick_stop_x, self.pick_stop_y = self.get_parameter('pick_stop_pixel_coordinate').value

        response.success = True
        return response

    def start_place_callback(self, request, response):
        self.get_logger().info("start place")
        self.set_parameter_autodeclare('status', 'start_place')
        self.place_ready_action()
        self.start_place = True
        self.start_pick = False
        self.pick = False
        self.place = False

        # 清 PID
        self.linear_pid.clear()
        self.angular_pid.clear()

        # 如果需要从参数 Server 更新
        self.place_stop_x, self.place_stop_y = self.get_parameter('place_stop_pixel_coordinate').value

        response.success = True
        return response
    
    def start_place_red_callback(self, request, response):
        self.get_logger().info("start place red_base (GPS mode)")
        self.start_place_red = True
        # self.start_place = False
        self.start_pick = False
        self.place_red = False
        self.pick = False
        self.place = False
        self.linear_pid.clear()
        self.angular_pid.clear()
        response.success = True
        return response
    

    # --------------------- 小工具：self.create_rate() ---------------------
    def create_rate(self, hz):
        """
        在 ROS2 Python 中没有像 rospy.Rate 那样的API，
        可以自己写一个简单的生成器或者直接用 time.sleep
        """
        return Rate(hz, self.get_clock())
    

class Rate:
    def __init__(self, hz, clock):
        self.period = 1.0 / hz
        self.clock = clock
        self.last_time = self.clock.now()

    def sleep(self):
        now = self.clock.now()
        elapsed = (now - self.last_time).nanoseconds / 1e9
        to_sleep = self.period - elapsed
        if to_sleep > 0:
            time.sleep(to_sleep)
        self.last_time = self.clock.now()

def main(args=None):
    rclpy.init(args=args)
    
    node = AutomaticPickNode()
    executor = MultiThreadedExecutor()
    executor.add_node(node)
    
    try:	
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()




    

